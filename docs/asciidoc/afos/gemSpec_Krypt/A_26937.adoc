[#A_26937]
==== A_26937 - ZETA/ASL-Protokoll: ZETA/ASL-Client: Nachricht 3

Ein ZETA/ASL-Client MUSS aus der Nachricht 2 (vgl.
A_26936-*) des ZETA/ASL-Servers mittels der Ciphertexte ECDH_ct und ML-KEM-768_ct und den privaten ephemeren Client-Schlüsseln aus A_26932-* (Nachricht 1) und der jeweiligen KEM-Decapsulation-Funktionen zwei Geheimnisse berechnen: ss_e_ecdh und ss_e_mlkem768. Er MUSS die beiden Geheimnisse zusammenfügen: ss_e = ss_e_ecdh || ss_e_ml_kem_768 und das Ergebnis mittels der HKDF [RFC-5869] auf Basis von SHA-256 verwenden (info = '' (leere Zeichenkette), um 64 Byte abzuleiten.
Die ersten 32 Byte (=256 Bit) heißen K1_c2s und die letzten 32 Byte heißen K1_s2c.

 Mit dem Schlüssel K1_s2c mittels AES/CGM (vgl. A_26934-*) MUSS der Ciphertext 
"AEAD_ct" entschlüsselt werden: die "signierten öffentlichen 
ZETA/ASL-Schlüssel" (vgl. A_26921-*) werden so als Klartext erhalten. Diese 
ZETA/ASL-Schlüssel MUSS er nach A_26938-* prüfen. Mittels der öffentlichen 
Schlüssel (ECDH_PK, ML-KEM-768_PK) MUSS er jeweils die 
KEM-Encapsulation-Funktion ausführen und er erhält zwei Geheimnisse: ss_s_ecdh 
und ss_s_mlkem768. Diese führt er zusammen: ss_s = ss_s_ecdh || ss_s_mlkem768. 
Weiter berechnet er ss = ss_e || ss_s.
 Dieses Geheimnis verwendet die HKDF [RFC-5859] auf Basis von SHA-256 (info = 
'' (leere Zeichenkette)), um 160 Byte (=5 * 32 Byte) abzuleiten. Er MUSS diese 
160 Byte in 32 Byte-Blöcke (von offset 0 bis zum Ende) auf folgende fünf 
Variablen (vier Schlüssel + eine KeyID) verteilen:

* K2_c2s_key_confirmation,
* K2_c2s_app_data,
* K2_s2c_key_confirmation,
* K2_s2c_app_data und

* KeyID (nicht vertraulich).
Diese ersten vier sind vertrauliche Schlüsselwerte für AES/GCM.
Die KeyID wird nach dem Handshake als eindeutige ID für die K2*_app_data Schlüssel dienen.

 Er MUSS eine Datenstruktur wie folgt erzeugen: 

{
"ECDH_ct" : client_kem_result_2["ECDH_ct"], "ML-KEM-768_ct" : client_kem_result_2["ML-KEM-768_ct"], "ERP" : False, "ESO" : False }

 ERP steht für "Enforce Replay Protection" und ESO steht für "Enforce Sequence 
Order". Innerhalb der Spezifikation heißt diese Datenstruktur 
Nachricht_3_inner_Layer. Diese Datenstruktur MUSS er per CBOR [RFC-CBOR] 
serialisieren/kodieren. Diese Serialisierung MUSS er mittels K1_c2s 
verschlüsseln (vgl. A_26934-*) (= "ciphertext_msg_3).
 Er MUSS die komplette Nachricht-1 (CBOR-Kodierung), die Nachricht-2 und 
ciphertext_msg_3 konkatenieren (= Transskript des Client) und davon den 
SHA-256-Hashwert berechnen. Diesen Hashwert MUSS er mittels 
K2_c2s_key_confirmation verschlüsseln (vgl. A_26934-*), das Chiffrat sei 
als aead_ciphertext_msg_3_key_confirmation hier bezeichnet.

 Dann MUSS er folgende Datenstruktur erzeugen: 

{
"MessageType" : "M3", "AEAD_ct" : ciphertext_msg_3, "AEAD_ct_key_confirmation" : aead_ciphertext_msg_3_key_confirmation }

 Diese Datenstruktur MUSS er per CBOR serialisieren, das Ergebnis ist 
Nachricht 3.
 Er MUSS die Nachricht 3 per äußeren HTTP-Request an das Aktensystem senden 
und dabei den Wert der ZETA/ASL-CID (vgl. A_26936) als URL-Pfadnamen verwenden, 
unter Verwendung der HTTP-POST-Methode.
