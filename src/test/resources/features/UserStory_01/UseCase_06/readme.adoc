[#UC_01_06]
== UseCase_01_06: Client authentisierung und autorisierung software attest SC 200

.UseCase_01_06
[cols="1,1a",options="autowidth"]
|===
| *Titel:* | Client authentisierung und autorisierung software attest SC 200

| Akteur: |
*MA einer LEI*

| weitere Akteure: |
- *ZETA Client*
- *Konnektor / TI-Gateway*
- *SMC-B*
- *PEP HTTP Proxy*
- *PDP Authorization Server*
- *PDP Datenbank*
- *PDP Policy Engine*

| Auslöser: |
Ein MA einer LEI möchte auf einen Resource Server zugreifen und muss sich dafür authentisieren und autorisieren.

| Kurzbeschreibung: |
Um auf einen Resource Server zugreifen zu können, benötigt der
Client ein Access Token vom PDP Authorization Server.
Stationäre ZETA Clients verwenden dafür den Token Exchange Flow mittels Software-Attestierung. +

| Vorbedingung: |
Der stationäre ZETA Client ist bereits beim ZETA Guard registriert, d.h. es existiert bereits eine
``client_id`` inklusive zugehörigem Schlüsselpaar.
Der Client hat keine bestehende Session (kein gültiges Refresh Token).

| Nebenbedingung: |
Es wird *HTTP/2* verwendet. (<<TA_A_26640_02>>)

| Ablauf: |
1. MA startet *Authentisierung/Autorisierung-Prozess (Token-Austausch)* über den ZETA Client.
2. Der ZETA Client fordert beim PDP Authorization Server eine Nonce an:
- ``GET /nonce`` (HTTP/2)
3. Der PDP Authorization Server liefert ``200 OK`` mit einer neuen Nonce zurück.
4. Der ZETA Client erstellt ein *DPoP Key Pair* (sitzungsbasiert).
- Zweck: Bindung für den späteren Token-Austausch.

5. Der ZETA Client berechnet eine *attestation challenge*:
- ``attestation_challenge = HASH(pubKeyHash + nonce)``

6. Der ZETA Client erstellt ein *Client Statement* mit *posture-software*.
+
.client_statement:
[source,txt]
----
- sub
- product_id
- product_version
- posture (containing attestation_challenge etc.)
- attestation-info
----
+

7. Der ZETA Client erstellt ein *Client Assertion JWT*.
+
.Client Assertion JWT Claims (with Attestation):
[source,json]
----
{
"iss": "<client_id>",
"sub": "<client_id>",
"aud": "<AS_Token_Endpoint_URL>",
"exp": "...",
"jti": "...",
// Embed the client_statement
"urn:gematik:params:oauth:client-attestation:software":
  {
    "attestation_data": "<Base64(client_statement)>",
    "client_statement_format": "client-statement"
  }
}
(sig by Client_Instance_Private_Key)
----
+

8. Der ZETA Client erstellt ein *SMC-B Access Token* (JWT).
+
.SMC-B Access Token Claims:
[source,json]
----
{
"iss": "<client_id>",// Issuer is the client
"sub": "<Telematik-ID from SMC-B>",// Subject is the institution
"aud": "[<Resource_Server_Endpoint_URL>]",// Audience is the Resource Server
"exp": "...",// Short-lived
"iat": "...",
"jti": "...",
"scope": "..." // As required for the Resource Server access
}
----
+

9. Der ZETA Client initiiert eine *External Authenticate*-Anfrage beim Konnektor / TI-Gateway:
- Übermittlung des JWT-Hash.
10. Der KTG reicht den Hash an die SMC-B weiter.
11. Die SMC-B antwortet mit signiertem Hash.
12. Der KTG liefert die *JWT-Signatur* zurück an den ZETA Client.

13. Der ZETA Client fügt die JWT-Signatur in das *SMC-B Access Token* ein.
14. Der ZETA Client erstellt ein *DPoP Proof JWT* für den Token-Austausch.
- Enthält Claims für den Token Request.
+
.DPoP Proof JWT Claims (for Token Exchange):
[source,json]
----
{
"typ": "dpop+jwt",
"alg": "ES256",
"jwk": { ... }
}.{
"jti": "...",
"htm": "POST","htu": "<AS_Token_Endpoint_URL>",
"nonce": "<nonce from AS>", // Binding to AS
"iat": "..."
}.(sig by DPoP_Private_Key)
----
+

15. Der ZETA Client sendet einen *Token Request* (<<RFC8693, RFC 8693>>, HTTP/2) an den PDP Authorization Server:
- Enthält ``DPoP: signed_dpop_jwt``.
+
.Token Exchange Request Body:
[source,txt]
----
grant_type=urn:ietf:params:oauth:grant-type:token-exchange
&subject_token=<SMC-B_Access_Token>
&subject_token_type=urn:ietf:params:oauth:token-type:jwt
&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer
&client_assertion=<Client_Assertion_JWT>...
----
+

16. Der PDP Authorization Server validiert den Request:
- Client Assertion
- Attestation
- DPoP Proof
- Subject Token
17. Der PDP Authorization Server ruft die Policy Engine (PDP-PE) auf:
- ``POST /v1/data/authz`` mit Input-Parametern.
18. Der PDP-PE antwortet mit ``200 OK``, z. B.
+
[source,txt]
----
{
status: 200 OK,
    body {
    "allow": true,
    "access_token_ttl": "360",
    "refresh_token_ttl": "43200",
    "scope": "RS specific scopes"
    }
}
----
+

19. Der PDP Authorization Server generiert ein *AS Access Token (AT)* sowie ein *Refresh Token (RT)*.
20. Der PDP Authorization Server aktualisiert die Client-, Session- und Nutzerdaten in der PDP Datenbank.
21. Die PDP Datenbank bestätigt Aktualisierung des Datensatzes.
22. Der PDP Authorization Server liefert ``200 OK`` mit den neuen Tokens an ZETA Client zurück.
+
.Token Response Body:
[source,json]
----
{
"access_token": "<AS_Access_Token>",
"token_type": "DPoP", // Indicate DPoP is required
"expires_in": 300,
"refresh_token": "<AS_Refresh_Token>"
// ... other parameters
}
----
+

23. Der ZETA Client informiert den MA über die erfolgreiche Zugriffrechtserteilung.

| Nachbedingung: |
Der stationäre ZETA Client kann auf einen Resource Server zugreifen, d.h. dieser ist authentisiert und autorisiert.

| Abgedeckte Testaspekte: |
* <<TA_A_18464_02>>
* <<TA_A_21275-01_03>>
* <<TA_A_21275-01_04>>
* <<TA_A_25337_01>>
* <<TA_A_25338_01>>
* <<TA_A_25338_02>>
* <<TA_A_25338_03>>
* <<TA_A_25453_01>>
* <<TA_A_25644_06>>
* <<TA_A_25644_07>>
* <<TA_A_25645_01>>
* <<TA_A_25649_01>>
* <<TA_A_25650_02>>
* <<TA_A_25660_01>>
* <<TA_A_25660_02>>
* <<TA_A_25660_04>>
* <<TA_A_25660_05>>
* <<TA_A_25661_01>>
* <<TA_A_25661_02>>
* <<TA_A_25661_04>>
* <<TA_A_25661_05>>
* <<TA_A_25662_01>>
* <<TA_A_25662_03>>
* <<TA_A_25663_01>>
* <<TA_A_25663_02>>
* <<TA_A_25664_01>>
* <<TA_A_25664_02>>
* <<TA_A_25739_01>>
* <<TA_A_25739_02>>
* <<TA_A_25739_03>>
* <<TA_A_25739_04>>
* <<TA_A_25739_05>>
* <<TA_A_25739_06>>
* <<TA_A_25739_07>>
* <<TA_A_25739_08>>
* <<TA_A_25739_09>>
* <<TA_A_25739_10>>
* <<TA_A_25739_11>>
* <<TA_A_25739_12>>
* <<TA_A_25760_01>>
* <<TA_A_25760_02>>
* <<TA_A_25760_03>>
* <<TA_A_25761_02>>
* <<TA_A_25762_03>>
* <<TA_A_25762_04>>
* <<TA_A_25762_05>>
* <<TA_A_25767_01>>
* <<TA_A_25767_02>>
* <<TA_A_26281_01>>
* <<TA_A_26585_01>>
* <<TA_A_26585_02>>
* <<TA_A_26586_01>>
* <<TA_A_26586_02>>
* <<TA_A_26640_02>>
* <<TA_A_26661_01>>
* <<TA_A_26944_01>>
* <<TA_A_26945_01>>
* <<TA_A_26972_01>>
* <<TA_A_26972_02>>
* <<TA_A_26972_03>>
* <<TA_A_26972_04>>
* <<TA_A_27007_01>>
* <<TA_A_27401_01>>
* <<TA_A_27727_01>>
* <<TA_A_27802_01>>
* <<TA_A_27802_02>>
* <<TA_A_27802_03>>
* <<TA_A_27802_04>>
* <<TA_A_27802_05>>
* <<TA_A_27802_06>>
* <<TA_A_27802_07>>
* <<TA_A_27802_08>>
* <<TA_A_27802_09>>
* <<TA_A_27802_10>>
* <<TA_A_27802_11>>
* <<TA_A_27802_12>>
* <<TA_A_27853_03>>
* <<TA_A_27853_04>>
* <<TA_A_27853_05>>
* <<TA_A_27853_08>>
* <<TA_A_27867_01>>
* <<TA_A_27867_02>>
* <<TA_A_27867_03>>
* <<TA_A_27867_04>>
* <<TA_A_28144_01>>
* <<TA_A_28144_02>>
* <<TA_A_28144_03>>
* <<TA_A_28144_04>>
* <<TA_GS-A_5542_03>>
* <<TA_GS-A_5542_04>>


|===

[#usecase_01_06_sequence]
[mermaid,usecase-01-06-sequence,svg]
....
sequenceDiagram
    autonumber

    actor MA as MA einer LEI
    participant ZC as ZETA Client
    participant KTG as Konnektor/<br>TI-Gateway
    participant SMC as SMC-B
    participant PDP-AS as PDP Authorization<br>Server
    participant PDP-DB as PDP Datenbank
    participant PDP-PE as PDP Policy Engine

    MA->>+ZC: Starte Prozess

    critical 1. Vorbereitung
        ZC->>+PDP-AS: HTTP/2 GET /nonce
        PDP-AS-->>ZC: 200 OK new-nonce: nonce
        ZC->>ZC: Erstelle DPoP Schlüsselpaar
        ZC->>ZC: Attestierungs-Challenge berechnen
    end

    critical 2. Erstellen des Client Statement
        ZC->>ZC: Erstellen Client Statement (posture-software)
        ZC->>ZC: Erzeuge Client Assertion (JWT)
    end

    critical 3. SMC-B Signatur holen
        ZC->>ZC: Erstellen von SMC-B Access Token (JWT)
        ZC->>+KTG: External Authenticate<br>(JWT-Hash)
        KTG->>+SMC: Signiere (Hash)
        SMC-->>-KTG: Signatur
        KTG->>-ZC: JWT-Signatur
    end

    critical 4. DPoP Proof erstellen
        ZC->>ZC: Hinzufügen von JWT-Signature<br>zu SMC-B Access Token
        ZC->>ZC: Erstellen von DPoP Proof JWT<br>für Token Exchange
    end

    critical 5. Validierung & Token-Ausgabe
        ZC->>PDP-AS: HTTP/2 POST /token (RFC 8693) DPoP: signed_dpop_jwt
        PDP-AS-->>PDP-AS: Validiere Request
        PDP-AS->>+PDP-PE: POST /v1/data/authz
        PDP-PE-->>-PDP-AS: 200 OK
        PDP-AS->>PDP-AS: Erzeuge AS Access Token (AT)<br>und Refresh Token (RT)
        PDP-AS->>+PDP-DB: Aktualisiere Client, Session & Nutzer-Daten
        PDP-DB->>-PDP-AS: OK
        PDP-AS-->>-ZC: 200 OK
        ZC-->>-MA: "Zugriff gestattet"
    end
....

[.lead]
Feature-Datei zu diesem Use Case:

- Komponententests und Integrationstests in einer gemeinsamen Datei:

[source]
----
include::Client_authentisierung_und_autorisierung_software_attest_SC_200.feature[]
----
