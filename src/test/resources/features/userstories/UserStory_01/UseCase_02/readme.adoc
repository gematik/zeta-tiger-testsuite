[#UC_01_02]
==== UseCase_01_02: Client authentisierung und autorisierung software attest SC 200

.UseCase_01_02
[cols="1,1a",options="autowidth"]
|===

| *Titel:* | Client authentisierung und autorisierung software attest SC 200

| Akteur: |

*MA einer LEI*: Mitarbeiter (MA) einer Leistungserbringerinstitution (LEI)

| weitere Akteure: |

- *ZC*: ZETA Client
- *KTG*: Konnektor / TI-Gateway
- *SMC*: SM( C )-B (Smartcard)
- *PHP*: PEP HTTP Proxy
- *PDP-AS*: PDP Authorization Server (AS)
- *PDP-DB*: PDP Datenbank
- *PDP-PE*: PDP Policy Engine
- *TF*: Testfachdienst

| Auslöser: | Ein MA eines Leistungserbringers möchte auf einen Fachdienst zugreifen und muss sich dafür authentisieren und autorisieren.

| Kurzbeschreibung: |
Nach erfolgreicher Registrierung besitzt der ZETA Client eine client_id und ein
zugehöriges Schlüsselpaar. Um auf einen Fachdienst zugreifen zu können, benötigt der
Client ein Access Token vom Authorization Server (AS). Stationäre ZETA Clients
verwenden dafür den Token Exchange Flow. +
In diesem Use Case soll der hierfür notwendige Token-Austausch mittels Software-Attestierung erfolgen.

| Vorbedingung: | Der stationäre ZETA Client ist bereits beim ZETA Guard registriert, d.h. es existiert bereits eine
client_id inkl. zugehörigem Schlüsselpaar.
Der Client hat keine bestehende Session (kein gültiges Refresh Token)

| Nebenbedingung: |
- Es wird *HTTP/2* verwendet <<A_26640>>

| Ablauf: |
1. MA startet *Authentisierung/Autorisierung-Prozess* über den ZETA Client (ZC).
2. ZC fordert bei PDP-AS eine Nonce an:
- `GET /nonce` (HTTP/2)
3. PDP-AS liefert `200 OK` mit einer neuen Nonce zurück.
4. ZC erstellt ein *DPoP Key Pair* (sitzungsbasiert).
- Zweck: Bindung für den späteren Token-Austausch.

5. ZC berechnet eine *attestation challenge*:
- Hash aus *Public Client Instance Key Hash* und Nonce.
- `attestation_challenge = HASH(pubKeyHash + nonce)`

6. ZC erstellt ein *Client Statement* mit *posture-software*.

.client_statement:
[source,txt]
----
- sub
- product_id
- product_version
- posture (containing attestation_challenge etc.)
- attestation-info
----

[start=7]
7. ZC erstellt ein *Client Assertion JWT*.

.Client Assertion JWT Claims (with Attestation):
[source,json]
----
{
"iss": "<client_id>",
"sub": "<client_id>",
"aud": "<AS_Token_Endpoint_URL>",
"exp": "...",
"jti": "...",
// Embed the client_statement
"urn:gematik:params:oauth:client-attestation:software":
  {
    "attestation_data": "<Base64(client_statement)>",
    "client_statement_format": "client-statement"
  }
}
(sig by Client_Instance_Private_Key)
----
[start=8]
. ZC erstellt ein *SMC-B Access Token* (JWT).

.SMC-B Access Token Claims:
[source,json]
----
{
"iss": "<client_id>",// Issuer is the client
"sub": "<Telematik-ID from SMC-B>",// Subject is the institution
"aud": "[<Resource_Server_Endpoint_URL>]",// Audience is the Resource Server
"exp": "...",// Short-lived
"iat": "...",
"jti": "...",
"scope": "..." // As required for the Resource Server access
}
----

[start=9]
. ZC initiiert eine *External Authenticate*-Anfrage beim Konnektor (KTG):
- Übermittlung des JWT-Hash.
. KTG reicht den Hash an die SMC-B weiter.
. SMC-B signiert den Hash.
. KTG liefert die *JWT-Signatur* zurück an ZC.

. ZC fügt die JWT-Signatur in das *SMC-B Access Token* ein.
. ZC erstellt ein *DPoP Proof JWT* für den Token-Austausch.
- Enthält Claims für den Token Request.

.DPoP Proof JWT Claims (for Token Exchange):
[source,json]
----
{
"typ": "dpop+jwt",
"alg": "ES256",
"jwk": { ... }
}.{
"jti": "..."
"htm": "POST","htu": "<AS_Token_Endpoint_URL>",
"nonce": "<nonce from AS>", // Binding to AS
"iat": "..."
}.(sig by DPoP_Private_Key)
----

[start=15]
. ZC sendet ein *Token Request* (<<RFC8693, RFC 8693>>, HTTP/2) an PDP-AS:
- Enthält `DPoP: signed_dpop_jwt`.

.Token Exchange Request Body:
[source,txt]
----
grant_type=urn:ietf:params:oauth:grant-type:token-exchange
&subject_token=<SM(C)-B_Access_Token>
&subject_token_type=urn:ietf:params:oauth:token-type:jwt
&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer
&client_assertion=<Client_Assertion_JWT>...
----

[start=16]
. PDP-AS validiert den Request:
- Client Assertion
- Attestation
- DPoP Proof
- Subject Token
. PDP-AS ruft die Policy Engine (PDP-PE) auf:
- `POST /v1/data/authz` mit Input-Parametern.
. PDP-PE antwortet mit `OK`, z. B.
[source,txt]
----
{
status: 200 OK,
    body {
    "allow": true,
    "access_token_ttl": "360",
    "refresh_token_ttl": "43200",
    "scope": "RS specific scopes"
    }
}
----

[start=19]
. PDP-AS generiert ein *AS Access Token (AT)* sowie ein *Refresh Token (RT)*.
. PDP-AS aktualisiert die Client-, Session- und Nutzerdaten in der PDP-DB.
. PDP-DB bestätigt aktualisierung des Datensatzes.
. PDP-AS liefert `200 OK` mit den neuen Tokens an ZC zurück.

.Token Response Body:
[source,json]
----
{
"access_token": "<AS_Access_Token>",
"token_type": "DPoP", // Indicate DPoP is required
"expires_in": 300,
"refresh_token": "<AS_Refresh_Token>"
// ... other parameters
}
----

[start=23]
. ZC meldet an MA: *„Access granted“*.

| Nachbedingung:  | Der stationäre ZETA-Client kann auf einen Fachdienst zugreifen, d.h. dieser ist authentisiert und
autorisiert.

| Abgedeckte Testaspekte: |

* <<TA_A_25660_01>>
* <<TA_A_25661_01>>
* <<TA_A_25661_02>>
* <<TA_A_25661_04>>
* <<TA_A_25661_05>>
* <<TA_A_25760_01>>
* <<TA_A_25760_03>>
* <<TA_A_25761_02>>
* <<TA_A_25762_03>>
* <<TA_A_25767_01>>
* <<TA_A_25767_02>>
* <<TA_A_26944_01>>
* <<TA_A_27007_01>>
* <<TA_A_27802_01>>
* <<TA_A_27802_02>>
* <<TA_A_27802_03>>
* <<TA_A_27802_04>>
* <<TA_A_27802_05>>
* <<TA_A_27802_06>>
* <<TA_A_27802_07>>
* <<TA_A_27802_08>>
* <<TA_A_27802_09>>
* <<TA_A_27802_10>>
* <<TA_A_27802_11>>
* <<TA_A_27802_12>>
* <<TA_A_28144_01>>
* <<TA_A_28144_02>>
* <<TA_A_28144_03>>
* <<TA_A_28144_04>>

|===

[mermaid]
....
sequenceDiagram
    autonumber
        actor MA as MA eines LEI
        participant ZC as ZETA Client
        participant KTG as Konnektor/<br/>TI-Gateway
        participant SMC as SM(C)-B
        participant PDP-AS as PDP Authorization<br/>Server (AS)
        participant PDP-DB as PDP Datenbank
        participant PDP-PE as PDP Policy Engine

    MA->>+ZC: Starte Prozess

    opt 1. Vorbereitung
        ZC->>+PDP-AS: HTTP/2 GET /nonce
        PDP-AS-->>ZC: 200 OK new-nonce: nonce
        ZC->>ZC: Erstelle DPoP Schlüsselpaar
        ZC->>ZC: Attestierungs-Challenge berechnen
    end

    opt 2. Erstellen des Client Statement
        ZC->>ZC: Erstellen Client Statement (posture-software)
        ZC->>ZC: Erzeuge Client Assertion (JWT)
    end

    opt 3. SMC-B Signatur holen
        ZC->>ZC: Erstellen von SMC-B Access Token (JWT)
        ZC->>+KTG: External Authenticate<br/>(JWT-Hash)
        KTG->>+SMC: Signiere (Hash)
        SMC-->>-KTG: Signatur
        KTG->>-ZC: JWT-Signatur
    end

    opt 4. DPoP Proof erstellen
        ZC->>ZC: Hinzufügen von JWT-Signature<br/>zu SMC-B Access Token
        ZC->>ZC: Erstellen von DPoP Proof JWT<br/>für Token Exchange
    end

    opt 5. Validierung & Token-Ausgabe
        ZC->>PDP-AS: HTTP/2 POST /token (RFC 8693) DPoP: signed_dpop_jwt
        PDP-AS-->>PDP-AS: Validiere Request
        PDP-AS->>+PDP-PE: POST /v1/data/authz
        PDP-PE-->>-PDP-AS: 200 OK
        PDP-AS->>PDP-AS: Erzeuge AS Access Token (AT)<br/>und Refresh Token (RT)
        PDP-AS->>+PDP-DB: Aktualisiere Session- &<br/>Client-Daten
        PDP-DB->>-PDP-AS: OK
        PDP-AS-->>-ZC: 200 OK
        ZC-->>-MA: "Zugriff gestattet"
    end
....

[.lead]
Feature-Datei zu diesem Use Case:

[%linenums,source,feature]
----
include::Client_authentisierung_und_autorisierung_software_attest_SC_200.feature[]
----
